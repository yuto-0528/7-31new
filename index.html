<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒˆãƒ©ãƒƒã‚«ãƒ¼</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2em;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .sensor-data {
      font-size: 0.9em;
      color: #555;
      background: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    .emotion-selection {
      margin-top: 1em;
      background: #f0f8ff;
      padding: 10px;
      border-radius: 5px;
    }
    label { margin-right: 1em; }
    textarea {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 16px;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 10px;
    }
    button:hover {
      background: #0056b3;
    }
    .stats {
      background: #e8f5e8;
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
    }
    .warning {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    #predictionResult {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      font-size: 1.2em;
      font-weight: bold;
      text-align: center;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      border: 1px solid #ccc;
    }
    .emotion-happy { background-color: #ffeb3b; }
    .emotion-angry { background-color: #f44336; color: white; }
    .emotion-sad { background-color: #2196f3; color: white; }
    .emotion-fun { background-color: #4caf50; color: white; }
    .emotion-default { background-color: #f0f0f0; }
  </style>
</head>
<body>
  <h1>ğŸ“± ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ãƒˆãƒ©ãƒƒã‚«ãƒ¼</h1>
  
  <div class="warning">
    <strong>æ³¨æ„:</strong> åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã¾ãŸã¯ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„ã€‚
  </div>
  
  <textarea id="typingArea" rows="6" placeholder="ã“ã“ã«ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã—ã¦ãã ã•ã„"></textarea>
  
  <div class="stats">
    <p><strong>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°æ•°:</strong> <span id="typeCount">0</span></p>
    <p><strong>å‰Šé™¤å›æ•°:</strong> <span id="deleteCount">0</span></p>
    <p><strong>æ‰“ã¡è¾¼ã¿æ™‚é–“:</strong> <span id="typingTime">0.0</span> ç§’</p>
  </div>
  
  <div class="sensor-data">
    <p><strong>ğŸ“Š åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼:</strong></p>
    <p>X: <span id="accelX">-</span></p>
    <p>Y: <span id="accelY">-</span></p>
    <p>Z: <span id="accelZ">-</span></p>
    <div id="sensorStatus"></div>
  </div>
  
  <div class="emotion-selection">
    <p><strong>ğŸ˜Š ä»Šã®æ„Ÿæƒ…ã‚’é¸ã‚“ã§ãã ã•ã„:</strong></p>
    <label><input type="radio" name="emotion" value="å–œ"> ğŸ˜Š å–œ</label>
    <label><input type="radio" name="emotion" value="æ€’"> ğŸ˜  æ€’</label>
    <label><input type="radio" name="emotion" value="å“€"> ğŸ˜¢ å“€</label>
    <label><input type="radio" name="emotion" value="æ¥½"> ğŸ˜„ æ¥½</label>
  </div>
  
  <button id="saveBtn">ğŸ’¾ ä¿å­˜</button>
  <button id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>

  <div id="predictionResult" class="emotion-default">
    ã“ã“ã«æ„Ÿæƒ…ãŒäºˆæ¸¬ã•ã‚Œã¾ã™
  </div>

  <script>
    const typingArea = document.getElementById('typingArea');
    const typeCountSpan = document.getElementById('typeCount');
    const deleteCountSpan = document.getElementById('deleteCount');
    const typingTimeSpan = document.getElementById('typingTime');
    const saveBtn = document.getElementById('saveBtn');
    const resetBtn = document.getElementById('resetBtn');
    const sensorStatus = document.getElementById('sensorStatus');
    const predictionResultDiv = document.getElementById('predictionResult');

    let typeCount = 0;
    let deleteCount = 0;
    let startTime = null;
    let timer = null;
    let accelX = 0, accelY = 0, accelZ = 0;
    let maxAccelX = 0, maxAccelY = 0, maxAccelZ = 0;

    typingArea.addEventListener('keydown', (e) => {
      if (!startTime) {
        startTime = Date.now();
        timer = setInterval(() => {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          typingTimeSpan.textContent = elapsed;
        }, 100);
      }
      
      if (e.key.length === 1) {
        typeCount++;
        typeCountSpan.textContent = typeCount;
      } else if (e.key === 'Backspace') {
        deleteCount++;
        deleteCountSpan.textContent = deleteCount;
      }
    });

    typingArea.addEventListener('blur', () => {
      if (timer) clearInterval(timer);
    });

    typingArea.addEventListener('focus', () => {
      if (startTime && !timer) {
        timer = setInterval(() => {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          typingTimeSpan.textContent = elapsed;
        }, 100);
      }
    });

    if (window.DeviceMotionEvent) {
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        sensorStatus.innerHTML = '<button onclick="requestSensorPermission()">ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ã‚’å–å¾—</button>';
      } else {
        startSensorTracking();
      }
    } else {
      sensorStatus.innerHTML = '<p style="color: red;">åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>';
    }

    function requestSensorPermission() {
      DeviceMotionEvent.requestPermission()
        .then(permissionState => {
          if (permissionState === 'granted') {
            startSensorTracking();
            sensorStatus.innerHTML = '<p style="color: green;">ã‚»ãƒ³ã‚µãƒ¼è¨±å¯æ¸ˆã¿ âœ“</p>';
          } else {
            sensorStatus.innerHTML = '<p style="color: red;">ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ</p>';
          }
        })
        .catch(console.error);
    }

    function startSensorTracking() {
      window.addEventListener('devicemotion', (event) => {
        accelX = event.accelerationIncludingGravity.x || 0;
        accelY = event.accelerationIncludingGravity.y || 0;
        accelZ = event.accelerationIncludingGravity.z || 0;
        
        if (Math.abs(accelX) > Math.abs(maxAccelX)) maxAccelX = accelX;
        if (Math.abs(accelY) > Math.abs(maxAccelY)) maxAccelY = accelY;
        if (Math.abs(accelZ) > Math.abs(maxAccelZ)) maxAccelZ = accelZ;
        
        document.getElementById('accelX').textContent = accelX.toFixed(2);
        document.getElementById('accelY').textContent = accelY.toFixed(2);
        document.getElementById('accelZ').textContent = accelZ.toFixed(2);
      });
      
      if (!sensorStatus.innerHTML.includes('è¨±å¯æ¸ˆã¿')) {
        sensorStatus.innerHTML = '<p style="color: green;">ã‚»ãƒ³ã‚µãƒ¼å‹•ä½œä¸­ âœ“</p>';
      }
    }

    // æ„Ÿæƒ…ã‚’äºˆæ¸¬ã—ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•° (æ–°ã—ã„é–¢æ•°)
    function predictAndDisplayEmotion() {
      // (1) ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã®å¼·ã•ã‚’è¨ˆç®—: å„è»¸ã®æœ€å¤§åŠ é€Ÿåº¦ã®çµ¶å¯¾å€¤ã®ä¸­ã§æœ€ã‚‚å¤§ãã„å€¤
      const overallMaxAccel = Math.max(Math.abs(maxAccelX), Math.abs(maxAccelY), Math.abs(maxAccelZ));
      
      // (2) ç§’é–“å‰Šé™¤å›æ•°ã‚’è¨ˆç®—
      const currentTypingTime = parseFloat(typingTimeSpan.textContent);
      const deletionRate = currentTypingTime > 0 ? deleteCount / currentTypingTime : 0;

      // (3) æ„Ÿæƒ…äºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ (é–¾å€¤ã¯èª¿æ•´å¯èƒ½ - å®Ÿéš›ã«ä½¿ã£ã¦ã¿ã¦èª¿æ•´ã—ã¦ãã ã•ã„)
      // â˜…å¤‰æ›´ç‚¹: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã®å¼·ã•ã®åŸºæº–ã¨ãªã‚‹é–¾å€¤
      const threshold_accel = 10.0; // ã“ã‚Œã‚ˆã‚Šå¤§ãã„ã¨ã€Œå¼·ã„ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã€ã€ãã‚Œä»¥ä¸‹ã ã¨ã€Œå¼±ã„ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã€ã¨åˆ¤æ–­

      // â˜…å¤‰æ›´ç‚¹: å‰Šé™¤å›æ•°ã®åŸºæº–ã¨ãªã‚‹é–¾å€¤
      const threshold_deletion = 0.2; // ç§’é–“0.2å›ä»¥ä¸Šã§ã€Œå‰Šé™¤ãŒå¤šã„ã€ã€æœªæº€ã§ã€Œå‰Šé™¤ãŒå°‘ãªã„ã€ã¨åˆ¤æ–­

      let predictedEmotion = "ä¸æ˜";
      let emotionClass = "emotion-default";

      // äºŒé …åˆ†é¡ã®åˆ¤å®š
      const isStrongTyping = overallMaxAccel > threshold_accel;
      const isHighDeletionRate = deletionRate >= threshold_deletion;

      // äºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ã®é©ç”¨ (2x2ãƒãƒˆãƒªãƒƒã‚¯ã‚¹)
      if (isHighDeletionRate) { // å‰Šé™¤ãŒå¤šã„å ´åˆ (æ€’ or å“€)
          if (isStrongTyping) {
              predictedEmotion = "æ€’"; // å¼·ã„ã‚¿ã‚¤ãƒ”ãƒ³ã‚° + å‰Šé™¤ãŒå¤šã„
              emotionClass = "emotion-angry";
          } else { // å¼±ã„ã‚¿ã‚¤ãƒ”ãƒ³ã‚° + å‰Šé™¤ãŒå¤šã„
              predictedEmotion = "å“€"; 
              emotionClass = "emotion-sad";
          }
      } else { // å‰Šé™¤ãŒå°‘ãªã„å ´åˆ (å–œ or æ¥½)
          if (isStrongTyping) {
              predictedEmotion = "å–œ"; // å¼·ã„ã‚¿ã‚¤ãƒ”ãƒ³ã‚° + å‰Šé™¤ãŒå°‘ãªã„
              emotionClass = "emotion-happy";
          } else { // å¼±ã„ã‚¿ã‚¤ãƒ”ãƒ³ã‚° + å‰Šé™¤ãŒå°‘ãªã„
              predictedEmotion = "æ¥½"; 
              emotionClass = "emotion-fun";
          }
      }

      // çµæœã‚’è¡¨ç¤º
      predictionResultDiv.textContent = `äºˆæ¸¬ã•ã‚ŒãŸæ„Ÿæƒ…: ${predictedEmotion}`;
      predictionResultDiv.className = ''; // æ—¢å­˜ã®ã‚¯ãƒ©ã‚¹ã‚’ã™ã¹ã¦å‰Šé™¤
      predictionResultDiv.classList.add(emotionClass); // æ–°ã—ã„æ„Ÿæƒ…ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
    }

    // ä¿å­˜ãƒœã‚¿ãƒ³å‡¦ç†
    saveBtn.addEventListener('click', () => {
      // æ„Ÿæƒ…ã‚’äºˆæ¸¬ã—ã¦è¡¨ç¤º (ä¿å­˜å‡¦ç†ã®å‰ã«å‘¼ã³å‡ºã™)
      predictAndDisplayEmotion(); 

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸æŠã—ãŸæ„Ÿæƒ…ã‚‚å–å¾— (ã“ã‚Œã¯GASã«ä¿å­˜ç”¨)
      const emotion = document.querySelector('input[name="emotion"]:checked');
      const data = {
        text: typingArea.value,
        typeCount: typeCount,
        deleteCount: deleteCount,
        typingTime: typingTimeSpan.textContent,
        maxAccel: { x: maxAccelX, y: maxAccelY, z: maxAccelZ },
        emotion: emotion ? emotion.value : '', // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸æŠã—ãŸæ„Ÿæƒ…
        timestamp: new Date().toISOString()
      };
      
      const gasUrl = 'https://script.google.com/macros/s/AKfycbz8Pyi2wHdqlaLBvJjfySji5IKO2aasGBkREc9lAnBT5RRWJMszZG4KILEetfwDZNMy/exec';
      console.log('GASã¸ã®é€ä¿¡URL:', gasUrl); // é€ä¿¡URLã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›

      // Google Apps Scriptã®Web APIã«é€ä¿¡
      fetch(gasUrl, {
        method: 'POST',
        body: JSON.stringify(data),
        headers: { 'Content-Type': 'application/json' }
      })
      .then(res => {
        if (!res.ok) { // HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ãŒ200ç•ªå°ä»¥å¤–ã®å ´åˆ
          throw new Error(`HTTPã‚¨ãƒ©ãƒ¼: ${res.status} ${res.statusText}`);
        }
        return res.text();
      })
      .then(msg => {
        // GASã¸ã®ä¿å­˜ãŒæˆåŠŸã—ãŸã¨ãã®ã‚¢ãƒ©ãƒ¼ãƒˆ
        alert('ãƒ‡ãƒ¼ã‚¿ã‚’Googleã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ã—ã¾ã—ãŸï¼'); 
        console.log("GASã‹ã‚‰ã®å¿œç­”:", msg);
      })
      .catch(err => {
        console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', err);
        alert('GASã¸ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚ã‚¨ãƒ©ãƒ¼è©³ç´°: ' + err.message); // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…·ä½“çš„ã«è¡¨ç¤º
      });
    });

    // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³å‡¦ç†
    resetBtn.addEventListener('click', () => {
      if (confirm('ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
        typingArea.value = '';
        typeCount = 0;
        deleteCount = 0;
        startTime = null;
        maxAccelX = maxAccelY = maxAccelZ = 0; // æœ€å¤§åŠ é€Ÿåº¦ã‚‚ãƒªã‚»ãƒƒãƒˆ
        
        typeCountSpan.textContent = '0';
        deleteCountSpan.textContent = '0';
        typingTimeSpan.textContent = '0.0';
        
        document.querySelectorAll('input[name="emotion"]').forEach(radio => {
          radio.checked = false;
        });
        
        if (timer) {
          clearInterval(timer);
          timer = null;
        }
        // äºˆæ¸¬çµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ã‚‚ãƒªã‚»ãƒƒãƒˆ
        predictionResultDiv.textContent = 'ã“ã“ã«æ„Ÿæƒ…ãŒäºˆæ¸¬ã•ã‚Œã¾ã™';
        predictionResultDiv.className = 'emotion-default'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è‰²ã«æˆ»ã™
      }
    });
  </script>
</body>
</html>